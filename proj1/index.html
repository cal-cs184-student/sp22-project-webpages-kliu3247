<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');.lst-kix_ki9wkrlohem9-7>li:before{content:"-  "}.lst-kix_cjc8gku6wqpc-3>li:before{content:"\0025cf  "}.lst-kix_cjc8gku6wqpc-4>li:before{content:"\0025cb  "}.lst-kix_maaek4nu843l-2>li:before{content:"\0025a0  "}.lst-kix_maaek4nu843l-4>li:before{content:"\0025cb  "}.lst-kix_ki9wkrlohem9-5>li:before{content:"-  "}ul.lst-kix_gf420eujtpa0-8{list-style-type:none}.lst-kix_cjc8gku6wqpc-5>li:before{content:"\0025a0  "}ul.lst-kix_gf420eujtpa0-7{list-style-type:none}.lst-kix_ki9wkrlohem9-6>li:before{content:"-  "}.lst-kix_cjc8gku6wqpc-1>li:before{content:"\0025cb  "}.lst-kix_maaek4nu843l-1>li:before{content:"\0025cb  "}.lst-kix_maaek4nu843l-5>li:before{content:"\0025a0  "}.lst-kix_cjc8gku6wqpc-0>li:before{content:"\0025cf  "}ul.lst-kix_gf420eujtpa0-4{list-style-type:none}.lst-kix_cjc8gku6wqpc-7>li:before{content:"\0025cb  "}.lst-kix_cjc8gku6wqpc-8>li:before{content:"\0025a0  "}ul.lst-kix_gf420eujtpa0-3{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-7{list-style-type:none}ul.lst-kix_gf420eujtpa0-6{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-8{list-style-type:none}.lst-kix_maaek4nu843l-0>li:before{content:"\0025cf  "}.lst-kix_maaek4nu843l-6>li:before{content:"\0025cf  "}.lst-kix_maaek4nu843l-8>li:before{content:"\0025a0  "}ul.lst-kix_gf420eujtpa0-5{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-5{list-style-type:none}ul.lst-kix_gf420eujtpa0-0{list-style-type:none}.lst-kix_cjc8gku6wqpc-6>li:before{content:"\0025cf  "}ul.lst-kix_cjc8gku6wqpc-6{list-style-type:none}.lst-kix_ki9wkrlohem9-0>li:before{content:"-  "}.lst-kix_ki9wkrlohem9-8>li:before{content:"-  "}ul.lst-kix_cjc8gku6wqpc-3{list-style-type:none}ul.lst-kix_gf420eujtpa0-2{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-4{list-style-type:none}.lst-kix_maaek4nu843l-7>li:before{content:"\0025cb  "}ul.lst-kix_gf420eujtpa0-1{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-1{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-2{list-style-type:none}ul.lst-kix_cjc8gku6wqpc-0{list-style-type:none}ul.lst-kix_q3lt2k78i6i2-8{list-style-type:none}ul.lst-kix_q3lt2k78i6i2-7{list-style-type:none}.lst-kix_maaek4nu843l-3>li:before{content:"\0025cf  "}.lst-kix_gf420eujtpa0-0>li:before{content:"\0025cf  "}.lst-kix_gf420eujtpa0-2>li:before{content:"\0025a0  "}.lst-kix_gf420eujtpa0-1>li:before{content:"\0025cb  "}.lst-kix_gf420eujtpa0-4>li:before{content:"\0025cb  "}.lst-kix_cjc8gku6wqpc-2>li:before{content:"\0025a0  "}.lst-kix_gf420eujtpa0-3>li:before{content:"\0025cf  "}.lst-kix_gf420eujtpa0-8>li:before{content:"\0025a0  "}.lst-kix_6jep5i7htdrl-8>li:before{content:"\0025a0  "}.lst-kix_gf420eujtpa0-5>li:before{content:"\0025a0  "}.lst-kix_gf420eujtpa0-6>li:before{content:"\0025cf  "}.lst-kix_gf420eujtpa0-7>li:before{content:"\0025cb  "}.lst-kix_6jep5i7htdrl-1>li:before{content:"\0025cb  "}.lst-kix_6jep5i7htdrl-0>li:before{content:"\0025cf  "}.lst-kix_6jep5i7htdrl-2>li:before{content:"\0025a0  "}.lst-kix_a3sm9vkong0d-8>li:before{content:"\0025a0  "}.lst-kix_6jep5i7htdrl-3>li:before{content:"\0025cf  "}.lst-kix_ki9wkrlohem9-1>li:before{content:"-  "}.lst-kix_ki9wkrlohem9-2>li:before{content:"-  "}.lst-kix_6jep5i7htdrl-4>li:before{content:"\0025cb  "}.lst-kix_ki9wkrlohem9-3>li:before{content:"-  "}.lst-kix_6jep5i7htdrl-5>li:before{content:"\0025a0  "}.lst-kix_6jep5i7htdrl-7>li:before{content:"\0025cb  "}.lst-kix_ki9wkrlohem9-4>li:before{content:"-  "}.lst-kix_6jep5i7htdrl-6>li:before{content:"\0025cf  "}.lst-kix_a3sm9vkong0d-0>li:before{content:"\0025cf  "}.lst-kix_a3sm9vkong0d-1>li:before{content:"\0025cb  "}ul.lst-kix_6jep5i7htdrl-0{list-style-type:none}ul.lst-kix_6jep5i7htdrl-2{list-style-type:none}ul.lst-kix_6jep5i7htdrl-1{list-style-type:none}.lst-kix_a3sm9vkong0d-6>li:before{content:"\0025cf  "}.lst-kix_a3sm9vkong0d-7>li:before{content:"\0025cb  "}ul.lst-kix_6jep5i7htdrl-8{list-style-type:none}ul.lst-kix_6jep5i7htdrl-7{list-style-type:none}ul.lst-kix_maaek4nu843l-8{list-style-type:none}ul.lst-kix_6jep5i7htdrl-4{list-style-type:none}ul.lst-kix_maaek4nu843l-6{list-style-type:none}ul.lst-kix_6jep5i7htdrl-3{list-style-type:none}ul.lst-kix_maaek4nu843l-7{list-style-type:none}ul.lst-kix_6jep5i7htdrl-6{list-style-type:none}ul.lst-kix_maaek4nu843l-4{list-style-type:none}.lst-kix_a3sm9vkong0d-5>li:before{content:"\0025a0  "}ul.lst-kix_6jep5i7htdrl-5{list-style-type:none}ul.lst-kix_maaek4nu843l-5{list-style-type:none}.lst-kix_a3sm9vkong0d-4>li:before{content:"\0025cb  "}.lst-kix_a3sm9vkong0d-2>li:before{content:"\0025a0  "}.lst-kix_a3sm9vkong0d-3>li:before{content:"\0025cf  "}ul.lst-kix_ki9wkrlohem9-0{list-style-type:none}ul.lst-kix_maaek4nu843l-2{list-style-type:none}ul.lst-kix_ki9wkrlohem9-1{list-style-type:none}ul.lst-kix_maaek4nu843l-3{list-style-type:none}ul.lst-kix_maaek4nu843l-0{list-style-type:none}ul.lst-kix_maaek4nu843l-1{list-style-type:none}ul.lst-kix_ki9wkrlohem9-8{list-style-type:none}ul.lst-kix_ki9wkrlohem9-6{list-style-type:none}ul.lst-kix_ki9wkrlohem9-7{list-style-type:none}ul.lst-kix_ki9wkrlohem9-4{list-style-type:none}ul.lst-kix_ki9wkrlohem9-5{list-style-type:none}ul.lst-kix_ki9wkrlohem9-2{list-style-type:none}.lst-kix_831om9z6p805-1>li:before{content:"\0025cb  "}ul.lst-kix_ki9wkrlohem9-3{list-style-type:none}.lst-kix_831om9z6p805-0>li:before{content:"\0025cf  "}ul.lst-kix_a3sm9vkong0d-7{list-style-type:none}ul.lst-kix_831om9z6p805-8{list-style-type:none}ul.lst-kix_a3sm9vkong0d-8{list-style-type:none}ul.lst-kix_831om9z6p805-7{list-style-type:none}ul.lst-kix_831om9z6p805-4{list-style-type:none}ul.lst-kix_831om9z6p805-3{list-style-type:none}ul.lst-kix_831om9z6p805-6{list-style-type:none}ul.lst-kix_831om9z6p805-5{list-style-type:none}.lst-kix_831om9z6p805-2>li:before{content:"\0025a0  "}.lst-kix_831om9z6p805-3>li:before{content:"\0025cf  "}.lst-kix_831om9z6p805-4>li:before{content:"\0025cb  "}.lst-kix_831om9z6p805-5>li:before{content:"\0025a0  "}.lst-kix_q3lt2k78i6i2-0>li:before{content:"\0025cf  "}ul.lst-kix_831om9z6p805-0{list-style-type:none}.lst-kix_831om9z6p805-7>li:before{content:"\0025cb  "}.lst-kix_831om9z6p805-8>li:before{content:"\0025a0  "}ul.lst-kix_831om9z6p805-2{list-style-type:none}ul.lst-kix_831om9z6p805-1{list-style-type:none}.lst-kix_831om9z6p805-6>li:before{content:"\0025cf  "}ul.lst-kix_q3lt2k78i6i2-0{list-style-type:none}ul.lst-kix_q3lt2k78i6i2-2{list-style-type:none}ul.lst-kix_q3lt2k78i6i2-1{list-style-type:none}.lst-kix_q3lt2k78i6i2-5>li:before{content:"\0025a0  "}.lst-kix_q3lt2k78i6i2-7>li:before{content:"\0025cb  "}ul.lst-kix_q3lt2k78i6i2-4{list-style-type:none}ul.lst-kix_q3lt2k78i6i2-3{list-style-type:none}ul.lst-kix_q3lt2k78i6i2-6{list-style-type:none}.lst-kix_q3lt2k78i6i2-4>li:before{content:"\0025cb  "}ul.lst-kix_q3lt2k78i6i2-5{list-style-type:none}.lst-kix_q3lt2k78i6i2-8>li:before{content:"\0025a0  "}.lst-kix_q3lt2k78i6i2-1>li:before{content:"\0025cb  "}.lst-kix_q3lt2k78i6i2-3>li:before{content:"\0025cf  "}.lst-kix_q3lt2k78i6i2-2>li:before{content:"\0025a0  "}ul.lst-kix_a3sm9vkong0d-0{list-style-type:none}ul.lst-kix_a3sm9vkong0d-1{list-style-type:none}ul.lst-kix_a3sm9vkong0d-2{list-style-type:none}ul.lst-kix_a3sm9vkong0d-3{list-style-type:none}ul.lst-kix_a3sm9vkong0d-4{list-style-type:none}ul.lst-kix_a3sm9vkong0d-5{list-style-type:none}.lst-kix_q3lt2k78i6i2-6>li:before{content:"\0025cf  "}ul.lst-kix_a3sm9vkong0d-6{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Helvetica Neue";font-style:normal}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;height:11pt}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c19{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c7{padding-top:11pt;padding-bottom:12pt;line-height:1.4;orphans:2;widows:2;text-align:left;height:12pt}.c5{color:#333333;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Helvetica Neue";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c9{padding-top:11pt;padding-bottom:12pt;line-height:1.4;orphans:2;widows:2;text-align:left}.c15{padding-top:0pt;padding-bottom:12pt;line-height:1.4;orphans:2;widows:2;text-align:left}.c30{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c6{padding-top:13pt;padding-bottom:12pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c25{-webkit-text-decoration-skip:none;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-style:normal}.c24{color:#999999;text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c29{color:#cccccc;text-decoration:none;vertical-align:baseline;font-style:normal}.c8{font-size:10pt;font-family:"Courier New";color:#333333;font-weight:400}.c16{color:#333333;text-decoration:none;vertical-align:baseline;font-style:normal}.c1{font-size:12pt;font-family:"Helvetica Neue";color:#333333;font-weight:400}.c18{font-family:"Helvetica Neue";color:#121212;font-weight:700}.c31{text-decoration:none;vertical-align:baseline;font-style:normal}.c10{font-size:12pt;font-family:"Helvetica Neue";font-weight:700}.c22{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c14{font-weight:400;font-family:"Helvetica Neue"}.c28{font-family:"Helvetica Neue";font-weight:700}.c3{font-style:italic}.c21{height:11pt}.c23{font-size:14pt}.c11{vertical-align:sub}.c32{font-size:19.5pt}.c17{color:#333333}.c27{font-size:12pt}.c26{text-indent:36pt}.c33{color:#000000}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c22"><div><p class="c20"><span class="c12"></span></p></div><h3 class="c6" id="h.cc4oiaswo36s"><span class="c16 c28 c32">Project 1: Rasterizer</span></h3><h3 class="c6" id="h.ih8wrxmyeybu"><span class="c18">CS 184: Computer Graphics and Imaging, Spring 2022</span></h3><p class="c30"><span class="c12">Kelly Liu</span></p><p class="c30"><span class="c12">Borche Antovski</span></p><p class="c13"><span class="c12"></span></p><h4 class="c9" id="h.svg46vavrcmn"><span class="c28 c23 c17">Overview</span></h4><h4 class="c15" id="h.c2fgi4lmw7b"><span class="c14">In this project, we worked on implementing a rasterizer with a variety of techniques we learned in lecture: sampling, transformations, barycentric interpolation, and texture mapping. Completing this project allowed us to build a rasterizer that generates and renders SVG files. </span><span class="c19">What is interesting about completing this project was the ability to see our code come to life. With each task we implemented, the results were immediate and we could see the work we&rsquo;ve done visually. Each task took us one step closer to a complete rasterizer - task 1 was to simply draw triangles, task 2 refined our triangles with antialiasing through super sampling, task 3 gave new functionalities with transformations, task 4 to 6 allowed us to apply different methods of texture mapping through colors, pixel sampling, and level sampling. Throughout this project, we experienced some bugs in our code - for example, in task 1 we had issues with drawing in both the clockwise and counterclockwise direction, and also segfault errors when we zoomed due to our calculations. We were able to troubleshoot all of these problems to successfully complete this project!</span></h4><p class="c20"><span class="c12"></span></p><h4 class="c9" id="h.r95h70fm9ar0"><span class="c28 c23 c17">Task 1 </span></h4><p class="c2"><span class="c1">Our algorithm creates</span><span class="c0">&nbsp;a bounding box of points where the triangle is to be rasterized. This allowed us to loop through and check each sample within the bounding box of the triangle - from the smallest X coordinate value to the largest X coordinate, and the smallest Y coordinate, and the largest Y coordinate. With each x,y coordinate, we calculated if it would be rasterized or not based on the point-in-triangle test equations - we had three equations (one for each side of the triangle) to determine if a point was in the triangle. If so, it was rasterized. We also accounted for each winding order case (counterclockwise vs clockwise) by determining the sign of the resulting value of the line equation. Finally, this algorithm has a much better runtime efficiency than just simply checking every pixel one by one, since we limited the number of pixels we check by defining a bounding box around the vertices of the triangle.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 554.50px; height: 437.20px;"><img alt="" src="images/image23.png" style="width: 554.50px; height: 437.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10">Figure 1. </span><span class="c14 c3 c27">png</span><span class="c14 c27">&nbsp;screenshot of </span><span class="c14 c3 c27">basic/test4.svg</span><span class="c31 c14 c27 c33">&nbsp;with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</span></p><p class="c2 c21"><span class="c5"></span></p><p class="c2"><span class="c23 c17 c28">Task 2 </span></p><p class="c2"><span class="c0">Our algorithm for task 2 adds to our algorithm from task 1. For each pixel in the frame_buffer, we divided it into multiple samples, based on the inputted sample_rate, and then did the point-in-triangle test for each of them. Based on the test we stored the value of these super samples in the sample_buffer vector. We chose to organize the sample_buffer in a way that we stored all the neighboring super samples of one pixel, next to each other in the vector. &nbsp;By doing this supersampling technique we manage to antialias the rasterization of the triangle, by setting each pixel of the frame_buffer to the average color of the super samples inside that pixel. To accomplish this besides changing rasterize_triangle, we needed to update other functions. We changed both set_sample_rate and set_framebuffer_target to resize the sample_buffer appropriately, taking into consideration the sample_rate. &nbsp;We changed the resolve_to_framebuffer to not only iterate through the pixels but to iterate through the individual values of the super samples stored into the sample_buffer for each specific pixel, and then set the value of the pixel to the average color of the super samples. Finally, one last thing that we changed is the fill_pixel function to account for the rasterization of borderlines, we did this by supersampling the pixels that were on the line and setting each of the super samples to the same color of the borderline. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 575.67px; height: 339.50px;"><img alt="" src="images/image29.png" style="width: 575.67px; height: 339.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10">Figure 2.a </span><span class="c1">of </span><span class="c1 c3">basic/test4.svg</span><span class="c0">&nbsp;with the default viewing parameters and sample rate 1</span></p><p class="c2 c21"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.50px; height: 319.82px;"><img alt="" src="images/image26.png" style="width: 553.50px; height: 319.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10">Figure 2.b </span><span class="c1">of </span><span class="c1 c3">basic/test4.svg</span><span class="c0">&nbsp;with the default viewing parameters and sample rate 4</span></p><h4 class="c7" id="h.133tfu71d649"><span class="c5"></span></h4><h4 class="c9" id="h.6v6m007q66i5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 593.50px; height: 342.40px;"><img alt="" src="images/image16.png" style="width: 593.50px; height: 342.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h4><p class="c2"><span class="c10">Figure 2.c </span><span class="c1">of </span><span class="c1 c3">basic/test4.svg</span><span class="c0">&nbsp;with the default viewing parameters and sample rate 9</span></p><p class="c20"><span class="c12"></span></p><h4 class="c9" id="h.a6mweuc83xo7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 360.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h4><p class="c2"><span class="c10">Figure 2.d </span><span class="c1">of </span><span class="c1 c3">basic/test4.svg</span><span class="c0">&nbsp;with the default viewing parameters and sample rate 16</span></p><h4 class="c7" id="h.exmmfvt49pw3"><span class="c5"></span></h4><h4 class="c9" id="h.n5ag6i97tak2"><span class="c5">Task 3 (10 pts)</span></h4><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 523.50px; height: 449.67px;"><img alt="" src="images/image25.png" style="width: 523.50px; height: 449.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10 c17">Figure 3. </span><span class="c0">Cubeman is dancing! We rotated Cubeman&rsquo;s left leg and arm by applying a 45 degree rotation. We also translated the limb positions so they fit the body positioning properly. Also changed the colors of a leg and arm. </span></p><p class="c20"><span class="c12"></span></p><h4 class="c9" id="h.nidn2se9cji3"><span class="c5">Task 4 (10 pts)</span></h4><p class="c2"><span class="c1">Barycentric coordinates are used to linearly interpolate values. In figure 4,each point is a hard set value of the RGB color scale. For each point V, within the triangle, an &#x1d770;, &#x1d7ab;, &#611;, value associated with V</span><span class="c1 c11">A</span><span class="c1">&nbsp;, V</span><span class="c1 c11">B</span><span class="c1">&nbsp;, and V</span><span class="c1 c11">c</span><span class="c1">&nbsp;respectively can be formed. These values are derived from the proportional distances from a perpendicular line drawn out of its respective vertex point to point V - for example, &#x1d770; is derived from a perpendicular line drawn from V</span><span class="c1 c11">A</span><span class="c1">&nbsp; to the line </span><img src="images/image1.png"><span class="c0">&nbsp;and then scaled proportionally based on the point &nbsp;V. &nbsp;We can then use these &#x1d770;, &#x1d7ab;, &#611; values to manipulate points on the screen that represent positions, texture, color, etc. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.50px; height: 333.65px;"><img alt="" src="images/image22.png" style="width: 403.50px; height: 333.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10 c17">Figure 4.a </span><span class="c0">Smoothly blended triangle. Picture taken from CS184 lecture 5.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 617.00px; height: 504.00px;"><img alt="" src="images/image28.png" style="width: 624.00px; height: 504.00px; margin-left: -7.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10 c17">Figure 4.b </span><span class="c1">a </span><span class="c1 c3">png</span><span class="c1">&nbsp;screenshot of </span><span class="c1 c3">svg/basic/test7.svg</span><span class="c1">&nbsp;with default viewing parameters and sample rate 1</span></p><h4 class="c7" id="h.2nqkezjqe26"><span class="c5"></span></h4><h4 class="c9" id="h.4z8152b42c4"><span class="c5">Task 5 (15 pts)</span></h4><p class="c2"><span class="c0">Pixel sampling maps the pixels of a screen to texture pixels, &ldquo;texels&rdquo;. We use pixel sampling to perform texture mapping for a more efficient and reliable method to do texture antialiasing.</span></p><p class="c2"><span class="c0">The two methods of pixel sampling are Nearest Pixel Sampling and Bilinear Pixel Sampling, both of which are implemented in this project. Nearest pixel sampling involves finding the closest value of a texel by rounding the corresponding texture coordinates of a given pixel location. Our implementation involved flooring input u,v locations and scaling them based on size of the texture map. </span></p><p class="c2"><span class="c1">Bilinear Pixel Filtering involves using linear interpolation to pinpoint texels. In our project, this is done through taking the four nearest sample texture values (instead of one, which was what was done in the nearest algorithm). The first step is to find the fractional offsets in the x and y direction of the point we want to map, as seen by the </span><span class="c1 c3">t </span><span class="c1">and </span><span class="c1 c3">s </span><span class="c1">values in figure 5.a. We can then compute 3 total linear interpolations based on the fractional offsets. The equation that dictates the linear interpolation between a point (</span><span class="c1 c3">v</span><span class="c1 c3 c11">0</span><span class="c1 c3">, v</span><span class="c1 c3 c11">1</span><span class="c1">) and its fractional offset (</span><span class="c1 c3">x</span><span class="c1">) is </span><img src="images/image2.png"><img src="images/image3.png"><span class="c1">. In figure 5.b, this would look like linearly interpolating the points in the horizontal direction with the fractional offset s and the point </span><span class="c1 c3">u</span><span class="c1 c3 c11">01</span><span class="c1 c3">&nbsp;</span><span class="c1">and u</span><span class="c1 c11">11</span><span class="c1">, </span><img src="images/image4.png"><img src="images/image5.png"><span class="c1">, as well as the fractional offset s and the point </span><span class="c1 c3">u</span><span class="c1 c3 c11">00</span><span class="c1 c3">&nbsp;</span><span class="c1">and u</span><span class="c1 c11">10</span><span class="c1">, </span><img src="images/image6.png"><img src="images/image7.png"><span class="c1">. Then finally doing a last linear interpolation calculation in the vertical direction with the fractional offset </span><span class="c1 c3">t </span><span class="c1">between </span><span class="c1 c3">u</span><span class="c1 c3 c11">1</span><span class="c1 c3">&nbsp;</span><span class="c1">and </span><span class="c1 c3">u</span><span class="c1 c3 c11">0</span><span class="c1">, &nbsp;</span><img src="images/image8.png"><img src="images/image9.png"><span class="c0">.</span></p><p class="c2 c26"><span class="c1">&nbsp; </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 198.50px; height: 182.51px;"><img alt="" src="images/image13.png" style="width: 198.50px; height: 182.51px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 185.75px; height: 204.66px;"><img alt="" src="images/image20.png" style="width: 185.75px; height: 204.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10 c17">Figure 5.a</span><span class="c1">&nbsp;fractional offsets of the red point</span><span class="c10 c17">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 5.b</span><span class="c0">&nbsp;linear interpolation points</span></p><p class="c2"><span class="c0">Figure 6 compares different pixel sampling methods and at different sampling rates. We also inspected a location in our map that best highlights the differences in pixel sampling methodologies.</span></p><p class="c2"><span class="c0">When looking at the supersample rate of 1 per pixel, the nearest pixel sampling algorithm gives us a blurry, less defined mapping. However, when we use bilinear pixel sampling (bilinear interpolation sampling), the edges of the map in the inspection tool show clear, defined edges.</span></p><p class="c2"><span class="c0">At a supersample rate of 16 per pixel, the nearest pixel sampling image gives us a blurry texture mapping. When bilinear pixel sampling is used, the edges are more clear and defined in the inspector tool. </span></p><p class="c2"><span class="c0">There are large differences in nearest versus bilinear sampling at areas where colors change drastically, as highlighted by our inspector tool (the drastic change between green and blue in the map). This is due to the nature of the algorithms - nearest sampling does not always accurately choose a color as it is doing rounding, while bilinear sampling takes the &ldquo;average&rdquo; of four of the nearest values to present a more accurate and holistic sample.</span></p><p class="c2 c21"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 457.40px; height: 361.45px;"><img alt="" src="images/image27.png" style="width: 457.40px; height: 361.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c10 c17">Figure 6.a </span><span class="c1">a </span><span class="c1 c3">png</span><span class="c1">&nbsp;screenshot of </span><span class="c1 c3">svg/texmap/test1.svg</span><span class="c0">&nbsp;with nearest sampling at 1 sample per pixel</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 441.80px; height: 329.60px;"><img alt="" src="images/image12.png" style="width: 441.80px; height: 329.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c10 c17">Figure 6.b </span><span class="c1">a </span><span class="c1 c3">png</span><span class="c1">&nbsp;screenshot of </span><span class="c1 c3">svg/texmap/test1.svg</span><span class="c0">&nbsp;with bilinear sampling at 1 sample per pixel</span></p><p class="c4 c21"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 459.80px; height: 362.55px;"><img alt="" src="images/image14.png" style="width: 459.80px; height: 362.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c10 c17">Figure 6.c </span><span class="c1">a </span><span class="c1 c3">png</span><span class="c1">&nbsp;screenshot of </span><span class="c1 c3">svg/texmap/test1.svg</span><span class="c0">&nbsp;with nearest sampling at 16 samples per pixel</span></p><p class="c4 c21"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 458.22px; height: 340.80px;"><img alt="" src="images/image21.png" style="width: 458.22px; height: 340.80px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c10 c17">Figure 6.d </span><span class="c1">a </span><span class="c1 c3">png</span><span class="c1">&nbsp;screenshot of </span><span class="c1 c3">svg/texmap/test1.svg</span><span class="c0">&nbsp;with bilinear sampling at 16 samples per pixel</span></p><h4 class="c7" id="h.acm5wdypogpx"><span class="c5"></span></h4><h4 class="c9" id="h.m2bbkdqp3urv"><span class="c28 c23 c17">Task 6 </span></h4><p class="c2"><span class="c0">Like pixel sampling, level sampling is used to do texture antialiasing when performing texture mapping. Level sampling is particularly useful when we do texture minification when we try to texture map a high-resolution texture space on a lower resolution screen space. In order to avoid aliasing due to having undersampling of the texture space, or in other words, having many texels contribute to a pixel, level sampling tries to decrease the resolution of the texture image, to a resolution that matches the screen sampling rate. By doing this we can achieve a desired 1-1 mapping between the screen space and the texture space that will eliminate aliasing. Finding the proper decreased resolution requires recursive low-pass filtering and downsampling of the texture image. We store each resulting lower resolution texture image as a separate level, with higher levels representing the most decreased resolution images.</span></p><p class="c2"><span class="c1">Given the different levels of the mipmap, in order to implement level sampling, we needed to approximate the level that corresponds to a texture file with a resolution that best matches the screen sampling rate. We did this by first computing &nbsp;</span><img src="images/image10.png"><span class="c1">&nbsp;inside of rasterize_textured_triangle by following the calculations given in the specs under step 1. We then used these two values to compute L = </span><img src="images/image11.png"><span class="c0">inside get_level and then using L we approximated the continuous level value D = log(L) / log(2). Based on the inputted lsm value, for lsm = L_NEAREST we rounded the D value and computed the specific pixel sampling using that D level, on the other hand for lsm = L_LINEAR we computed the specific pixel sampling both using the floor(D) and ceil(D) levels, then we did a linear interpolation on the two.</span></p><p class="c2"><span class="c1">The ideal sampling technique would be case dependent. For example, in images where there are lots of levels/depth and a need for good resolution, level sampling would be ideal. For situations where there isn&rsquo;t any drastic color change, nearest pixel sampling would be superior. Although supersampling is effective for high sampling needs, it is extremely costly in terms of speed and memory. Generally, the ideal sampling method for the best antialiasing ability, good speed, and best memory usage would be level sampling. Below is a more comprehensive breakdown of speed, memory usage, and antialiasing power for each technique:</span></p><p class="c2"><span class="c25 c1">Pixel Sampling</span></p><p class="c2"><span class="c0">Speed: Fast for nearest, Slow for bilinear</span></p><p class="c2"><span class="c0">Memory usage: Low (don&rsquo;t store any computation result)</span></p><p class="c2"><span class="c1">Antialiasing power: pixel sampling struggles to properly produce images where textures are minified. Complex, minified images produce antialiasing and can become problematic when an image has different level perspectives to it. There is often no good compromise between images with perspective that produces good definition as well as no anti-aliasing in minified sections of an image. (This is why level sampling is used).</span></p><p class="c2"><span class="c25 c1">Level Sampling </span></p><p class="c2"><span class="c0">Speed: Fast for nearest, Slow for linear (Faster than super sampling, slower then bilinear pixel sampling)</span></p><p class="c2"><span class="c0">Memory usage: Low (don&#39;t store any computation result)</span></p><p class="c2"><span class="c0">Antialiasing power: Most efficient at antialiasing when we do texture minification, texture mapping from high resolution texture space to low resolution screen space.</span></p><p class="c2"><span class="c1 c25">Number of Samples per Pixel</span></p><p class="c2"><span class="c0">Speed: Slow</span></p><p class="c2"><span class="c0">Memory usage: High</span></p><p class="c2"><span class="c0">Antialiasing power: Supersampling is very effective at high sampling rate, and can get rid of almost all aliasing, however it costs a lot of memory as we need to save each super sample value and it requires a lot of computation.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 401.33px;"><img alt="" src="images/image18.png" style="width: 624.00px; height: 401.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10 c17">Figure 7.a</span><span class="c1">&nbsp; </span><span class="c1 c3">png</span><span class="c1">&nbsp;file we found using </span><span class="c8">L_ZERO</span><span class="c1">&nbsp;and </span><span class="c8">P_NEAREST</span></p><p class="c2 c21"><span class="c12"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 409.33px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 409.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c10 c17">Figure 7.b</span><span class="c1">&nbsp; </span><span class="c1 c3">png</span><span class="c1">&nbsp;file we found using </span><span class="c8">L_ZERO</span><span class="c1">&nbsp;and </span><span class="c8">P_LINEAR</span></p><p class="c2 c21"><span class="c12"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 440.00px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 440.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c10 c17">Figure 7.c</span><span class="c1">&nbsp; </span><span class="c1 c3">png</span><span class="c1">&nbsp;file we found using </span><span class="c8">L_NEAREST</span><span class="c1">&nbsp;and </span><span class="c8 c31">P_NEAREST</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 457.33px;"><img alt="" src="images/image24.png" style="width: 624.00px; height: 457.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c10 c17">Figure 7.d</span><span class="c1">&nbsp; </span><span class="c1 c3">png</span><span class="c1">&nbsp;file we found using </span><span class="c8">L_NEAREST</span><span class="c1">&nbsp;and </span><span class="c8">P_LINEAR</span></p></body></html>
